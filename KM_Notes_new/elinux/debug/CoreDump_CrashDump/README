
Introduction  to CrashDump/CoreDump:
-----------------------------------
Whenever an application crashes, the operating system can store (or even send) a crash report.
On Linux, whenever an app crashes (most commonly by a segmentation fault, i.e. when accessing a bad pointer/memory), it has the option of generating a core dump.

A core dump is a file containing a process's address space (memory) when the process terminates unexpectedly. 
Core dumps may be produced on-demand (such as by a debugger), or automatically upon termination. 
Core dumps are triggered by the kernel in response to program crashes, and may be passed to a helper program (such as systemd-coredump) for further processing. 

We can use the core dump to diagnose and debug our computer programs by loading the core file into a debugger along with the executable file (for symbols and other debugging information). 

What Information coredump contain:
---------------------------------
It also contains a snapshot of all the virtual memory areas accessed by your app, so yes, there can be confidential information stored in a core dump so be careful who you give it to.

**************************************************************************************************************
						Coredump @ userspace
**************************************************************************************************************
How to enable coredump:
----------------------
You can check whether core dump files are enabled with the following command:
$ ulimit -c

By default core dump files are disabled, in which case this command will return 0. To enable core dump files, use the following command:
$ ulimit -c unlimited

$ ls -la /proc/sys/kernel/core*
-rw-r--r--. 1 root root 0 Aug 28 23:53 core_pattern
-rw-r--r--. 1 root root 0 Aug 28 16:12 core_pipe_limit
-rw-r--r--. 1 root root 0 Aug 28 23:53 core_uses_pid

$ cat /proc/sys/kernel/core_pattern
|/usr/libexec/abrt-hook-ccpp %s %c %p %u %g %t e

Note that the first character of the pattern is a "|", the kernel will treat the rest of the pattern as a command to run. The core dump will be written to the standard input of that program instead of to a file.

We need to change the line of the core_pattern to "core".
$ sudo bash -c 'echo core.%e.%p > /proc/sys/kernel/core_pattern'
$ cat /proc/sys/kernel/core_pattern
core.%e.%p

In the setting, %e is for executable file name and %p is for pid.

$ gcc -g error.c -o error
$ ulimit -c unlimited
$ ./error
Segmentation fault (core dumped)
$ ls
core.error.3209 error error.c
   
Analyzing Core File:
-------------------
gdb <executable> <core-file>

$ gdb ./error core.error.4981
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
[New LWP 4981]
Core was generated by `./error'.
Program terminated with signal SIGSEGV, Segmentation fault.
#0  0x00000000004004fd in fun () at error.c:5
5	    *ptr = 7;
(gdb) 

It indicates the line 5 has an issue.
We can use backtrace to list the call stacks that had been made when the program crashed:
(gdb) bt
#0  0x00000000004004fd in fun () at error.c:5
#1  0x0000000000400513 in main () at error.c:10
(gdb) up
#1  0x0000000000400513 in main () at error.c:10
10	    fun();
(gdb) down
#0  0x00000000004004fd in fun () at error.c:5
5	    *ptr = 7;

***************************************************************************************************************
						Coredump @ Kernelspace
***************************************************************************************************************

Using kdump and kexec analyze the kernel coredump files.

kexec:
-----
kexec is directly boot into a new kernel without going through BIOS.
Kexec is a fastboot mechanism that allows booting a Linux kernel from the context of an already running kernel without going through BIOS. 
BIOS can be very time consuming, especially on big servers with numerous peripherals. 
This can save a lot of time for developers who end up booting a machine numerous times
kexec is a system call that enables you to load and boot into another kernel from the currently running  kernel.
kexec performs the function of the boot loader from within the kernel. The primary difference between a standard system boot and a kexec boot is that the hardware initialization normally performed  by  the  BIOS  or  firmware (depending  on  architecture)  is  not  performed  during a kexec boot. 
This has the effect of reducing the time required for a reboot

kdump:
-----
Kdump is a new kernel crash dumping mechanism and is very reliable. 
The crash dump is captured from the context of a freshly booted kernel and not from the context of the crashed kernel. 
Kdump uses Kexec to boot into a second kernel whenever the system crashes. 
This second kernel, often called a crash or a capture kernel, boots with very little memory and captures the dump image.
The first kernel reserves a section of memory that the second kernel uses to boot. 
Kexec enables booting the capture kernel without going through BIOS hence the contents of the first kernelâ€™s memory are preserved, which is essentially the kernel crash dump.

kdump is a feature of the Linux kernel that creates crash dumps in the event of a kernel crash. When triggered, kdump exports a memory image (also known as vmcore) that can be analyzed for the purposes of debugging and determining the cause of a crash.


Enable the below kernel configuration options & compile:
-------------------------------------------------------
System kernel config options:
----------------------------
1) Enable "kexec system call" in "Processor type and features."
This parameter tells the system to use Kexec to skip BIOS and boot (new) kernels. It is critical for the functionality of Kdump.
   CONFIG_KEXEC=y

2) Enable "sysfs file system support" in "Filesystem" -> "Pseudo
   filesystems." This is usually enabled by default
   CONFIG_SYSFS=y

3) Enable "Compile the kernel with debug info" in "Kernel hacking."
   This causes the kernel to be built with debug symbols. The dump analysis tools require a vmlinux with debug symbols in order to read and analyze a dump file
   CONFIG_DEBUG_INFO=y

Dump-capture kernel config options (Arch Independent):
------------------------------------------------------
1) Enable kernel crash dumps: Crash dumps need to be enabled. Without this option, Kdump will be useless.
   CONFIG_CRASH_DUMP=y

2) Enable "/proc/vmcore support" under "Filesystems" -> "Pseudo filesystems".
   CONFIG_PROC_VMCORE=y
   (CONFIG_PROC_VMCORE is set by default when CONFIG_CRASH_DUMP is selected.)

Dump-capture kernel config options (Arch Dependent, i386 and x86_64)
--------------------------------------------------------------------
1) If one wants to build and use a relocatable kernel,
   Enable "Build a relocatable kernel" support under "Processor type and
   features"
   CONFIG_RELOCATABLE=y

2) Optional: Disable Symmetric Multi-Processing (SMP) support: Kdump can only work with a single processor. 
If you have only a single processor or you run your machine with SMP support disabled, you can safely set this parameter to (n).
   CONFIG_SMP=n
   KDUMP_COMMANDLINE_APPEND="maxcpus=1"
(If CONFIG_SMP=y, then specify maxcpus=1 on the kernel command line when loading the dump-capture kernel, see section "Load the Dump-capture Kernel".)

3) Use a suitable value for "Physical address where the kernel is loaded" (under "Processor type and features"). 
   This only appears when "kernel crash dumps" is enabled. A suitable value depends upon whether kernel is relocatable or not.

   If you are using a relocatable kernel use CONFIG_PHYSICAL_START=0x100000
   This will compile the kernel for physical address 1MB, but given the fact kernel is relocatable, it can be run from any physical address hence kexec boot loader will load it in memory region reserved for dump-capture kernel.

Otherwise it should be the start of memory region reserved for second kernel using boot parameter "crashkernel=Y@X". 
Here X is start of memory region reserved for dump-capture kernel.
   Generally X is 16MB (0x1000000). So you can set CONFIG_PHYSICAL_START=0x1000000

5) Make and install the kernel and its modules.

Dump-capture kernel config options (Arch Dependent, arm)
----------------------------------------------------------
1)  To use a relocatable kernel,
    Enable "AUTO_ZRELADDR" support under "Boot" options:
    AUTO_ZRELADDR=y

Install Kdump & Kexec:
--------------------
$ sudo apt-get install linux-crashdump

crash kernel recommendations:
----------------------------
For memory between 2G through 4G, reserve 320M
For memory between 4G through 32G, reserve 512M
For memory between 32G through 64G, reserve 1024M
For memory between 64G through 128G, reserve 2048M
For memory above 128G, reserve 4096M

add "crashkernel=256M" in /boot/grub/grub.cfg file.
Example:
--------
Command line: BOOT_IMAGE=/boot/vmlinuz-4.4.88 root=UUID=aab9b05c-202b-42c6-8be6-c90e9d6af8e8 ro quiet splash crashkernel=256M vt.handoff=7

$ kdump-config status
$ kdump-config show
$ kdump-config load
$ cat /proc/sys/kernel/sysrq
$ sudo sysctl -w kernel.sysrq=1


Core Dump Analyze:
-----------------
1) using gdb tool

$ sudo gdb KM_GIT/linux-4.4.88/vmlinux /var/crash/201712022302/vmcore.201712022302
[sudo] password for kernel: 
GNU gdb (Ubuntu 7.7.1-0ubuntu5~14.04.3) 7.7.1
Copyright (C) 2014 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
<http://www.gnu.org/software/gdb/bugs/>.
Find the GDB manual and other documentation resources online at:
<http://www.gnu.org/software/gdb/documentation/>.
For help, type "help".
Type "apropos word" to search for commands related to "word"...
Reading symbols from KM_GIT/linux-4.4.88/vmlinux...done.
[New LWP 2451]
[New LWP 1120]
[New process 1]
[New LWP 2142]
#0  sysrq_handle_crash (key=99) at drivers/tty/sysrq.c:138
138		*killer = 1;
warning: File "/home/kernel/KM_GIT/linux-4.4.88/scripts/gdb/vmlinux-gdb.py" auto-loading has been declined by your `auto-load safe-path' set to "$debugdir:$datadir/auto-load".
To enable execution of this file add
	add-auto-load-safe-path /home/kernel/KM_GIT/linux-4.4.88/scripts/gdb/vmlinux-gdb.py
line to your configuration file "/home/kernel/.gdbinit".
To completely disable this security protection add
	set auto-load safe-path /
line to your configuration file "/home/kernel/.gdbinit".
For more information about this security protection see the
"Auto-loading safe path" section in the GDB manual.  E.g., run from the shell:
	info "(gdb)Auto-loading safe path"
(gdb) bt
#0  sysrq_handle_crash (key=99) at drivers/tty/sysrq.c:138
#1  0xffffffff814c28c9 in __handle_sysrq (key=99, check_mask=false) at drivers/tty/sysrq.c:545
#2  0xffffffff814c2d18 in write_sysrq_trigger (file=<optimized out>, buf=<optimized out>, count=1, ppos=<optimized out>)
    at drivers/tty/sysrq.c:1091
#3  0xffffffff8126828d in proc_reg_write (file=<optimized out>, buf=<optimized out>, count=<optimized out>, 
    ppos=<optimized out>) at fs/proc/inode.c:216
#4  0xffffffff811fd558 in __vfs_write (file=0xffff8802411b8700, p=<optimized out>, count=<optimized out>, 
    pos=0x0 <irq_stack_union>) at fs/read_write.c:489
#5  0xffffffff811fdc12 in vfs_write (file=0x63 <irq_stack_union+99>, buf=0xffff88024f40dd98 "", count=<optimized out>, 
    pos=0xffff88024307bf20) at fs/read_write.c:538
#6  0xffffffff811fe936 in SYSC_write (count=<optimized out>, buf=<optimized out>, fd=<optimized out>)
    at fs/read_write.c:585
#7  SyS_write (fd=<optimized out>, buf=15049736, count=2) at fs/read_write.c:577
#8  0xffffffff817e6e36 in entry_SYSCALL_64_fastpath () at arch/x86/entry/entry_64.S:185
#9  0x0000000000e8f608 in ?? ()
#10 0x0000000000000004 in irq_stack_union ()

2) using crash tool
-------------------
$ crash <debug kernel> <crash dump> 

$ sudo crash KM_GIT/linux-4.4.88/vmlinux /var/crash/201712022302/vmcore.201712022302

crash 7.0.3
Copyright (C) 2002-2013  Red Hat, Inc.
Copyright (C) 2004, 2005, 2006, 2010  IBM Corporation
Copyright (C) 1999-2006  Hewlett-Packard Co
Copyright (C) 2005, 2006, 2011, 2012  Fujitsu Limited
Copyright (C) 2006, 2007  VA Linux Systems Japan K.K.
Copyright (C) 2005, 2011  NEC Corporation
Copyright (C) 1999, 2002, 2007  Silicon Graphics, Inc.
Copyright (C) 1999, 2000, 2001, 2002  Mission Critical Linux, Inc.
This program is free software, covered by the GNU General Public License,
and you are welcome to change it and/or distribute copies of it under
certain conditions.  Enter "help copying" to see the conditions.
This program has absolutely no warranty.  Enter "help warranty" for details.
 
GNU gdb (GDB) 7.6
Copyright (C) 2013 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "x86_64-unknown-linux-gnu"...


      KERNEL: KM_GIT/linux-4.4.88/vmlinux       
    DUMPFILE: /var/crash/201712022302/vmcore.201712022302
        CPUS: 4
        DATE: Thu Jan  1 05:30:00 1970
      UPTIME: 00:05:51
LOAD AVERAGE: 0.36, 0.52, 0.29
       TASKS: 367
    NODENAME: KernelMasters
     RELEASE: 4.4.88
     VERSION: #1 SMP Fri Dec 1 22:09:18 IST 2017
     MACHINE: x86_64  (2711 Mhz)
      MEMORY: 7.9 GB
       PANIC: "Oops: 0002 [#1] SMP " (check log for details)
         PID: 2451
     COMMAND: "bash"
        TASK: ffff880243510000  [THREAD_INFO: ffff880243078000]
         CPU: 0
       STATE: TASK_RUNNING (PANIC)

crash> 
crash> help

*              files          mach           repeat         timer          
alias          foreach        mod            runq           tree           
ascii          fuser          mount          search         union          
bt             gdb            net            set            vm             
btop           help           p              sig            vtop           
dev            ipcs           ps             struct         waitq          
dis            irq            pte            swap           whatis         
eval           kmem           ptob           sym            wr             
exit           list           ptov           sys            q              
extend         log            rd             task           

crash version: 7.0.3    gdb version: 7.6
For help on any command above, enter "help <command>".
For help on input options, enter "help input".
For help on output options, enter "help output".

crash> ps
   PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM
      0      0   0  ffffffff81c13500  RU   0.0       0      0  [swapper/0]
      0      0   1  ffff880245699e00  RU   0.0       0      0  [swapper/1]
>     0      0   2  ffff88024569ad00  RU   0.0       0      0  [swapper/2]
      0      0   3  ffff88024569bc00  RU   0.0       0      0  [swapper/3]
      1      0   3  ffff880245b58000  IN   0.0   34060   4576  init

crash> bt
PID: 2451   TASK: ffff880243510000  CPU: 0   COMMAND: "bash"
 #0 [ffff88024307bac0] machine_kexec at ffffffff8105919c
 #1 [ffff88024307bb18] crash_kexec at ffffffff81106153
 #2 [ffff88024307bbe0] oops_end at ffffffff8101aae9
 #3 [ffff88024307bc08] no_context at ffffffff81066f3d
 #4 [ffff88024307bc60] __bad_area_nosemaphore at ffffffff810672b9
 #5 [ffff88024307bca8] bad_area_nosemaphore at ffffffff810673d3
 #6 [ffff88024307bcb8] __do_page_fault at ffffffff810679c0
 #7 [ffff88024307bd10] do_page_fault at ffffffff81067d82
 #8 [ffff88024307bd30] page_fault at ffffffff817e8fb8
    [exception RIP: sysrq_handle_crash+22]
    RIP: ffffffff814c2116  RSP: ffff88024307bde0  RFLAGS: 00010296
    RAX: 000000000000000f  RBX: ffffffff81cbb800  RCX: 0000000000000000
    RDX: 0000000000000001  RSI: ffff88024f40dd98  RDI: 0000000000000063
    RBP: ffff88024307bde0   R8: ffffffff81f19ed4   R9: 0000000000000030
    R10: ffffffff81f0937c  R11: 0000000000000358  R12: 0000000000000063
    R13: 0000000000000000  R14: 0000000000000004  R15: 0000000000000000
    ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018
 #9 [ffff88024307bde8] __handle_sysrq at ffffffff814c28c9
#10 [ffff88024307be18] write_sysrq_trigger at ffffffff814c2d18
#11 [ffff88024307be30] proc_reg_write at ffffffff8126828d
#12 [ffff88024307be50] __vfs_write at ffffffff811fd558
#13 [ffff88024307bed0] vfs_write at ffffffff811fdc12
#14 [ffff88024307bf10] sys_write at ffffffff811fe936
#15 [ffff88024307bf50] entry_SYSCALL_64_fastpath at ffffffff817e6e36
    RIP: 00007f6f67b15390  RSP: 00007ffca2f8acd8  RFLAGS: 00000246
    RAX: ffffffffffffffda  RBX: 00000000004b7ddd  RCX: 00007f6f67b15390
    RDX: 0000000000000002  RSI: 0000000000e5a408  RDI: 0000000000000001
    RBP: 00000000004b7ddd   R8: 000000000000000a   R9: 00007f6f68423740
    R10: 00007f6f67de76a0  R11: 0000000000000246  R12: 0000000000e74e88
    R13: 0000000000000004  R14: 0000000000000004  R15: 0000000000e8f608
    ORIG_RAX: 0000000000000001  CS: 0033  SS: 002b
crash> 
crash> 
crash> kmem -i
              PAGES        TOTAL      PERCENTAGE
 TOTAL MEM  1944950       7.4 GB         ----
      FREE  1641126       6.3 GB   84% of TOTAL MEM
      USED   303824       1.2 GB   15% of TOTAL MEM
    SHARED    43821     171.2 MB    2% of TOTAL MEM
   BUFFERS    15850      61.9 MB    0% of TOTAL MEM
    CACHED   136661     533.8 MB    7% of TOTAL MEM
      SLAB    13080      51.1 MB    0% of TOTAL MEM

TOTAL SWAP  3999999      15.3 GB         ----
 SWAP USED        0            0    0% of TOTAL SWAP
 SWAP FREE  3999999      15.3 GB  100% of TOTAL SWAP

crash> irq
 IRQ   IRQ_DESC/_DATA      IRQACTION      NAME
  0   ffff88024682e800  ffffffff81c19a40  "timer"
  1   ffff88024682ea00  ffff88022c002f80  "i8042"
  2   ffff88024682ec00      (unused)      
  3   ffff88024682ee00      (unused)      
  4   ffff88024682f000      (unused)      
  5   ffff88024682f200      (unused)      
  6   ffff88024682f400      (unused)      
  7   ffff88024682f600      (unused)      
  8   ffff88024682f800  ffff88022c05c180  "rtc0"
  9   ffff88024682fa00  ffff88024516c100  "acpi"
 10   ffff88024682fc00      (unused)      
 11   ffff88024682fe00      (unused)      
 12   ffff880246888000  ffff88022c002f00  "i8042"
 13   ffff880246888200      (unused)      
 14   ffff880246888400  ffff8800a2cc7b00  "INT344B:00"
 15   ffff880246888600      (unused)      
 16   ffff880245363800  ffff88009906a380  "idma64.0"
                        ffff8800a6d07b00  "i2c_designware.0"
 17   ffff88022cdffe00  ffff88009906a980  "idma64.1"
              

3) apport-retrace tool:
----------------------
$ apport-retrace --stdout --rebuild-package-info /var/crash/linux-image*.crash 

****************************************************************************************************************
Kernel Panic

Oops


